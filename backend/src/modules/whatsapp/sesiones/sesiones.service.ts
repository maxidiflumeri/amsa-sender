import { Injectable, Logger, OnModuleInit } from '@nestjs/common';
import { Client, LocalAuth, Message } from 'whatsapp-web.js';
import { PrismaService } from 'src/prisma/prisma.service';
import { Redis } from 'ioredis';
import * as fs from 'fs';
import * as path from 'path';

@Injectable()
export class SesionesService implements OnModuleInit {
    private readonly logger = new Logger(SesionesService.name);
    private readonly sesiones: Record<string, any> = {};
    private redis: Redis;

    constructor(private readonly prisma: PrismaService) { }

    async onModuleInit() {
        this.logger.log('üöÄ Inicializando SesionesService y conectando a Redis...');
        this.redis = new Redis({
            host: process.env.REDIS_HOST,
            port: parseInt(process.env.REDIS_PORT || '6379'),
            maxRetriesPerRequest: null,
        });
        await this.cargarSesionesActivas();
    }

    getSesion(id: string) {
        return this.sesiones[id];
    }

    getSesionesActivas() {
        return Object.entries(this.sesiones).map(([id, s]) => ({
            id,
            estado: s.estado,
            ani: s.ani,
        }));
    }

    async conectarNuevaSesion(sessionId: string) {
        this.logger.log(`üîå Iniciando nueva sesi√≥n: ${sessionId}`);
        const client = new Client({
            authStrategy: new LocalAuth({ clientId: sessionId }),
            puppeteer: { args: ['--no-sandbox', '--disable-setuid-sandbox'] },
        });

        this.sesiones[sessionId] = { client, estado: 'inicializando' };

        client.on('qr', (qr) => {
            this.logger.log(`üì≤ QR generado para sesi√≥n ${sessionId}`);
            this.sesiones[sessionId].qr = qr;
            this.sesiones[sessionId].estado = 'esperando escaneo';
            this.redis.publish('estado-sesion', JSON.stringify({ estado: 'qr', qr, ani: '', sessionId }));
        });

        client.on('authenticated', async () => {
            this.logger.log(`üîê Sesi√≥n ${sessionId} autenticada`);
            this.sesiones[sessionId].estado = 'iniciando_sesion';
            await this.redis.publish('estado-sesion', JSON.stringify({ estado: 'iniciando_sesion', qr: '', ani: '', sessionId }));
        });

        client.on('ready', async () => {
            const ani = `${client.info.wid.user}-${client.info.pushname}`;
            this.sesiones[sessionId].estado = 'conectado';
            this.sesiones[sessionId].ani = ani;

            await this.redis.publish('estado-sesion', JSON.stringify({ estado: 'conectado', qr: '', ani, sessionId }));

            await this.prisma.sesion.upsert({
                where: { sessionId },
                update: { estado: 'conectado', ani },
                create: { sessionId, estado: 'conectado', ani },
            });

            this.logger.log(`‚úÖ Sesi√≥n ${sessionId} conectada como ${ani}`);
        });

        client.on('auth_failure', (msg) => {
            this.logger.warn(`‚ùå Fallo de autenticaci√≥n en sesi√≥n ${sessionId}: ${msg}`);
            this.redis.publish('estado-sesion', JSON.stringify({ estado: 'fallo_autenticacion', sessionId, mensaje: msg }));
        });

        client.on('disconnected', async () => {
            this.logger.log(`‚ö†Ô∏è Sesi√≥n ${sessionId} desconectada`);
            this.sesiones[sessionId].estado = 'desconectado';
            await this.prisma.sesion.update({ where: { sessionId }, data: { estado: 'desconectado' } });
            await this.redis.publish('estado-sesion', JSON.stringify({ estado: 'desconectado', qr: '', ani: '', sessionId }));
        });

        client.on('message', async (msg) => {
            await this.registrarMensaje({ msg, client, sessionId });
        });

        client.on('message_create', async (msg) => {
            if (msg.fromMe) {
                await this.registrarMensaje({ msg, client, sessionId });
            }
        });

        await client.initialize().catch((error) => {
            this.logger.error(`‚ùå Error al inicializar sesi√≥n ${sessionId}: ${error.message}`, error.stack);
        });
    }

    async cargarSesionesActivas() {
        this.logger.log('üîÑ Cargando sesiones activas desde la base de datos...');
        const sesionesDB = await this.prisma.sesion.findMany({ where: { estado: 'conectado' } });
        for (const { sessionId } of sesionesDB) {
            try {
                await this.reconectarSesion(sessionId);
            } catch (err) {
                this.logger.error(`‚ùå Error reconectando sesi√≥n ${sessionId}: ${err.message}`, err.stack);
            }
        }
    }

    async reconectarSesion(sessionId: string) {
        this.logger.log(`üîÅ Reintentando conexi√≥n de sesi√≥n ${sessionId}...`);
        const client = new Client({
            authStrategy: new LocalAuth({ clientId: sessionId }),
            puppeteer: { args: ['--no-sandbox', '--disable-setuid-sandbox'] },
        });

        this.sesiones[sessionId] = { client, estado: 'reconectando' };

        client.on('ready', async () => {
            const ani = `${client.info.wid.user}-${client.info.pushname}`;
            this.sesiones[sessionId] = { client, estado: 'conectado', ani };
            await this.prisma.sesion.update({ where: { sessionId }, data: { estado: 'conectado', ani } });
            await this.redis.publish('estado-sesion', JSON.stringify({ estado: 'conectado', qr: '', ani, sessionId }));
            this.logger.log(`‚úÖ Sesi√≥n ${sessionId} reconectada como ${ani}`);
        });

        client.on('message', async (msg) => {
            await this.registrarMensaje({ msg, client, sessionId });
        });

        client.on('message_create', async (msg) => {
            if (msg.fromMe) {
                await this.registrarMensaje({ msg, client, sessionId });
            }
        });

        client.on('auth_failure', (msg) => {
            this.sesiones[sessionId].estado = 'fallo de autenticaci√≥n';
            this.logger.warn(`‚ùå Auth failure en sesi√≥n ${sessionId}: ${msg}`);
        });

        client.on('disconnected', async () => {
            this.sesiones[sessionId].estado = 'desconectado';
            await this.prisma.sesion.update({ where: { sessionId }, data: { estado: 'desconectado' } });
            this.logger.log(`‚ö†Ô∏è Sesi√≥n ${sessionId} desconectada`);
        });

        await client.initialize();
        return this.sesiones[sessionId];
    }

    async limpiarSesiones() {
        for (const id of Object.keys(this.sesiones)) {
            await this.eliminarSesionPorId(id);
        }
        this.logger.log('üßπ Todas las sesiones en memoria fueron limpiadas.');
    }

    async eliminarSesionPorId(sessionId: string) {
        const sesion = this.sesiones[sessionId];
        if (!sesion) {
            this.logger.warn(`‚ö†Ô∏è Intento de eliminar sesi√≥n no existente: ${sessionId}`);
            return;
        }

        const estado = sesion.estado;
        try {
            if (estado !== 'desconectado' && sesion?.client) {
                if (sesion.client.pupBrowser?.isConnected()) {
                    await sesion.client.pupBrowser.close().catch((err) => {
                        this.logger.warn(`‚ö†Ô∏è Error cerrando Puppeteer en sesi√≥n ${sessionId}: ${err.message}`);
                    });
                }
                await sesion.client.destroy();
            }
        } catch (err) {
            this.logger.error(`‚ùå Error al destruir sesi√≥n ${sessionId}: ${err.message}`, err.stack);
        }

        delete this.sesiones[sessionId];
        this.logger.log(`üóëÔ∏è Sesi√≥n ${sessionId} eliminada de memoria.`);
    }

    async borrarCarpetaSesion(sessionId: string) {
        const nombreCarpeta = `session-${sessionId}`;
        const ruta = path.join(__dirname, '..', '..', '..', '.wwebjs_auth', nombreCarpeta);
        if (fs.existsSync(ruta)) {
            await fs.promises.rm(ruta, { recursive: true, force: true });
            this.logger.log(`üóÇÔ∏è Carpeta de sesi√≥n eliminada: ${nombreCarpeta}`);
        }
    }

    async borrarTodasLasCarpetasSesion() {
        const basePath = path.join(__dirname, '..', '..', '..', '.wwebjs_auth');
        const archivos = await fs.promises.readdir(basePath);
        const carpetasSesion = archivos.filter((nombre) => nombre.startsWith('session-'));
        for (const carpeta of carpetasSesion) {
            const ruta = path.join(basePath, carpeta);
            await fs.promises.rm(ruta, { recursive: true, force: true });
            this.logger.log(`üóÇÔ∏è Carpeta eliminada: ${carpeta}`);
        }
    }

    private normalizarNumero(numeroRaw: string): string {
        return numeroRaw.replace('@c.us', '').replace('@s.whatsapp.net', '');
    }

    private async registrarMensaje({
        msg,
        client,
        sessionId,
    }: {
        msg: Message;
        client: Client;
        sessionId: string;
    }) {
        try {
            const fromMe = msg.fromMe;
            const numeroRaw = msg.fromMe ? msg.to : msg.from;
            const numero = this.normalizarNumero(numeroRaw);
            const ani = `${client.info.wid.user}-${client.info.pushname}`;
            const fecha = msg.timestamp ? new Date(msg.timestamp * 1000) : new Date();
            const tipo = msg.type;
            let campa√±aId: number | null = null;

            const asignarCampa√±a = async () => {
                if (!fromMe) {
                    const ultimoEnviado = await this.prisma.mensaje.findFirst({
                        where: {
                            numero,
                            fromMe: true,
                            campa√±aId: { not: null },
                        },
                        orderBy: { fecha: 'desc' },
                    });

                    if (ultimoEnviado) {
                        const yaRespondido = await this.prisma.mensaje.findFirst({
                            where: {
                                numero,
                                fromMe: false,
                                campa√±aId: ultimoEnviado.campa√±aId,
                                fecha: { gt: ultimoEnviado.fecha },
                            },
                        });

                        if (!yaRespondido) {
                            return ultimoEnviado.campa√±aId;
                        }
                    }
                }
                return null;
            };

            if (msg.hasMedia) {
                const mediaMsg = msg as Message & { caption?: string };
                const media = await msg.downloadMedia();               

                let mimetype = media?.mimetype?.toLowerCase() || '';
                const filename = media?.filename ? ` (${media.filename})` : '';

                let mensaje = 'üìÅ Archivo' + filename;

                if (mimetype.startsWith('image/')) {
                    mensaje = `üì∑ Imagen${filename}`;
                } else if (mimetype.startsWith('video/')) {
                    mensaje = `üé• Video${filename}`;
                } else if (mimetype.startsWith('audio/')) {
                    mensaje = `üéß Audio${filename}`;
                } else if (mimetype === 'application/pdf') {
                    mensaje = `üìÑ Documento PDF${filename}`;
                } else if (mimetype.includes('word')) {
                    mensaje = `üìÑ Documento Word${filename}`;
                } else if (mimetype.includes('excel')) {
                    mensaje = `üìä Documento Excel${filename}`;
                }

                campa√±aId = await asignarCampa√±a();

                await this.prisma.mensaje.create({
                    data: {
                        numero,
                        mensaje,
                        fromMe,
                        fecha,
                        tipo,
                        ani,
                        campa√±aId,
                    },
                });

                this.logger.log(`[${fromMe ? 'ENVIADO' : 'RECIBIDO'}] ${numero}: ${mensaje}`);

                // Guardar caption si vino
                if (mediaMsg.caption?.trim()) {
                    await this.prisma.mensaje.create({
                        data: {
                            numero,
                            mensaje: mediaMsg.caption.trim(),
                            fromMe,
                            fecha,
                            tipo: 'texto',
                            ani,
                            campa√±aId,
                        },
                    });

                    this.logger.log(`[${fromMe ? 'ENVIADO' : 'RECIBIDO'}] ${numero}: ${mediaMsg.caption.trim()}`);
                }
                // üìù Guardar caption si viene
                const caption = this.obtenerCaption(msg);
                if (caption) {
                    await this.prisma.mensaje.create({
                        data: {
                            numero,
                            mensaje: caption,
                            fromMe,
                            fecha,
                            tipo: 'texto',
                            ani,
                            campa√±aId,
                        },
                    });

                    this.logger.log(`[${fromMe ? 'ENVIADO' : 'RECIBIDO'}] ${numero}: ${caption}`);
                }
            } else {
                const mensaje = msg.body;
                campa√±aId = await asignarCampa√±a();

                await this.prisma.mensaje.create({
                    data: {
                        numero,
                        mensaje,
                        fromMe,
                        fecha,
                        tipo,
                        ani,
                        campa√±aId,
                    },
                });

                this.logger.log(`[${fromMe ? 'ENVIADO' : 'RECIBIDO'}] ${numero}: ${mensaje}`);
            }
        } catch (err) {
            this.logger.error(`‚ùå Error registrando mensaje: ${err.message}`, err.stack);
        }
    }

    private obtenerCaption(msg: Message): string | null {
        return (msg as any)._data?.caption?.trim() || null;
    }
}